<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<!-- Global site tag (gtag.js) - Google Analytics -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-2E561F2422"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());
		  gtag('config', 'G-2E561F2422');
		</script>
		<!--
		************************************************
		The script above is for google analytics.
		You'll want to remove that if you use this page.
		************************************************
		-->
		<title>Bauhaus Pattern Creator</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<script src="https://d3js.org/d3.v5.min.js"></script>
		<link rel="preconnect" href="https://fonts.gstatic.com">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Rubik&display=swap">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;500&display=swap">
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>
	<body>

		<div id="options">

			<h1>Bauhaus<br>Pattern<br>Creator</h1>

			<table id="initial">
				<tr><td>Bauhaus</td></tr>
				<tr><td>Pattern</td></tr>
				<tr><td>Creator</td></tr>
			</table>

			<table id="heading">
				<tr><td>B</td><td>a</td><td>u</td><td>h</td><td>a</td><td>u</td><td>s</td></tr>
				<tr><td>P</td><td>a</td><td>t</td><td>t</td><td>e</td><td>r</td><td>n</td></tr>
				<tr><td>C</td><td>r</td><td>e</td><td>a</td><td>t</td><td onclick="createWallpapers()">o</td><td>r</td></tr>
			</table>

			<table>
				<tr>
					<th>Rows:</th>
					<td><input type="number" value="6" id="rows" min="1"></td>
				</tr>
				<tr>
					<th>Columns:</th>
					<td><input type="number" value="6" id="columns" min="1"></td>
				</tr>
				<tr>
					<th>Cell Size:</th>
					<td><input type="number" value="100" id="unitSize" min="10"></td>
				</tr>
				<tr>
					<th>Gap Size:</th>
					<td><input type="number" value="0" id="gapSize" min="0"></td>
				</tr>
				<tr>
					<th>Multiple Sizes:</th>
					<td>
						<select id="maxScale">
							<option value="1">No</option>
							<option value="2" selected>Max 2x2</option>
							<option value="4">Max 4x4</option>
							<option value="8">Max 8x8</option>
							<option value="16">Max 16x16</option>
							<option value="32">Max 32x32</option>
							<option value="64">Max 64x64</option>
						</select>
					</td>
				</tr>
				<tr>
					<th>Repetition:</th>
					<td>
						<select id="maxRepetition">
							<option value="1">No</option>
							<option value="2" selected>Max 2x2</option>
							<option value="4">Max 4x4</option>
							<option value="8">Max 8x8</option>
							<option value="16">Max 16x16</option>
							<option value="32">Max 32x32</option>
							<option value="64">Max 64x64</option>
						</select>
					</td>
				</tr>
				<tr>
					<th>Shapes:</th>
					<td>
						<select id="patternSet">
							<option value="everything" selected>All</option>
							<option value="" disabled>--------</option>
							<option value="curves">Curves</option>
							<option value="diagonals">Diagonals</option>
							<option value="lines">Lines</option>
							<option value="straights">Straights</option>
							<option value="triangles">Triangles</option>
						</select>
					</td>
				</tr>
				<tr>
					<th>Colours:</th>
					<td>
						<select id="colourSet">
							<option value="random" selected>Random Set</option>
							<option value="procgen">Random</option>
							<option value="" disabled>--------</option>
						</select>
					</td>
				</tr>
				<tr>
					<th>Symmetry:</th>
					<td>
						<select id="mirror">
							<option value="none" selected>No</option>
							<!--<option value="random">Random</option>-->
							<option value="horizontal">Horizontal</option>
							<option value="vertical">Vertical</option>
							<option value="both">Both</option>
						</select>
					</td>
				</tr>
			</table>

			<input type="button" value="Create" onclick="createPattern()">

			<div class="mobile_no">
				<input type="button" value="Download PNG" id="downloadPNG" onclick="downloadImagePNG()"><br>
				<input type="button" value="Download SVG" id="downloadSVG" onclick="downloadImageSVG()">
				<p class="about"><a href="https://github.com/Robson/Bauhaus-Pattern-Creator">Code</a> by <a href="https://robson.plus/">Robson</a></p>
			</div>
		</div>

		<div id="output"></div>

		<div class="mobile_yes">
			<div id="footer">
				<input type="button" value="Download PNG" id="downloadMobilePNG" onclick="downloadImagePNG()"><br>
				<input type="button" value="Download SVG" id="downloadMobileSVG" onclick="downloadImageSVG()">
				<p class="about"><a href="https://github.com/Robson/Bauhaus-Pattern-Generator">Code</a> by <a href="https://robson.plus/">Robson</a></p>
			</div>
		</div>

		<script>

			const lines = 4;
			var colours = ['black', 'white'];
			var procgen = [];

			setInterval(function () { colourHeading(); }, 60 * 1000);
			d3.select('h1').style('display', 'none');
			d3.select('#downloadSVG').style('display', 'none');
            d3.select('#downloadPNG').style('display', 'none');
			d3.select('#footer').style('display', 'none');
			d3.select('#heading').style('display', 'none');

			var colourSchemes = {
				Marigold:   ['#FFB510', '#FFFFFF', '#000000'],
				Maritime:   ['#FF444B', '#2AA4CF', '#FDF6EC'],
                Melancholy: ['#96371A', '#E2832B', '#312E30', '#A6A9B7', '#647496'],
				Memory:     ['#8A4B42', '#84785E', '#D1CECC', '#B4B4BA'],
				Memphis:    ['#672394', '#F725A0', '#FAD141', '#0CB2C0', '#E8E6D9'],
                Merlot:     ['#89363E', '#40262B', '#E7DFE0', '#100708'],
				Miami:      ['#18C0EF', '#F14F7B', '#F7AA1C'],
				Midnight:   ['#000000', '#254769', '#1B1C3B'],
				Mondrian:   ['#FAC901', '#225095', '#DD0100', '#FFFFFF'],
                Mono:       ['#FFFFFF', '#000000'],
				Monochrome: ['#222222', '#777777', '#CCCCCC'],
                Morning:    ['#F1C40F', '#E67E22', '#E74C3C', '#3498DB'],
                Mountain:   ['#84B9AA', '#21462C', '#577D76', '#FFFFFF'],
                Mulberry:   ['#D52439', '#110C1A', '#EACBAA'],
				Mulch:      ['#606C38', '#283618', '#DDA15E', '#BC6C25'],
                Mushroom:   ['#C55633', '#692D1B', '#838B69', '#C2BFA7'],
                Mystic:     ['#EDAD7B', '#ED78AD', '#311B2E', '#2C86A6'],
			};

			for (var scheme in colourSchemes) {
				d3.select('#colourSet')
					.append('option')
					.attr('value', scheme)
					.text(scheme);
			}

			function colourHeading() {
				d3.selectAll('#heading td').classed('x', function () { return Math.random() > 0.5 });
				d3.select('h1').style('display', 'none');
				d3.select('#initial').style('display', 'none');
				d3.select('#heading').style('display', null);
			}

			function getDateTimeFilename() {
				var filename = (new Date()).toISOString();
				console.log(filename);
				filename = filename.split('.')[0];
				filename = filename
					.replace(':', '-')
					.replace(':', '-')
					.replace('T', ' ');
				return filename;
			}

			function downloadImageSVG() {
				var svgEl = document.getElementById("render");
				d3.select('#render').attr("xmlns", "http://www.w3.org/2000/svg");
				var svgData = new XMLSerializer().serializeToString(svgEl);
				var preface = '<?xml version="1.0" standalone="no"?>\r\n';
				var svgBlob = new Blob([preface, svgData], { type: "image/svg+xml;charset=utf-8" });
				var svgUrl = URL.createObjectURL(svgBlob);
				var downloadLink = document.createElement("a");
				downloadLink.href = svgUrl;
				downloadLink.download = 'BPC ' + getDateTimeFilename() + '.svg';
				document.body.appendChild(downloadLink);
				downloadLink.click();
				document.body.removeChild(downloadLink);
			}

			function downloadImagePNG(filename='') {
                const render = document.querySelector('svg');
                const xml = (new XMLSerializer()).serializeToString(render);
                const blob = new Blob([xml], {
                    type: 'image/svg+xml;charset=utf-8'
                });
                const url = URL.createObjectURL(blob);
                const image = new Image();
                image.addEventListener('load', () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = +(d3.select('svg').attr('width').replace('px', ''));
					canvas.height = +(d3.select('svg').attr('height').replace('px', ''));
                    const context = canvas.getContext('2d');
                    context.drawImage(image, 0, 0, canvas.width, canvas.height);
                    URL.revokeObjectURL(url);
                    const link = document.createElement('a');
                    if (filename.length > 0) {
                    	link.download = 'BPC ' + getDateTimeFilename() + ' ' + filename + '.png';
                    } else {
                    	link.download = 'BPC ' + getDateTimeFilename() + '.png';
                    }
                    document.body.appendChild(link);
                    link.href = canvas.toDataURL();
                    link.click();
                    link.remove();
                });
                image.src = url;
			}

			function createWallpapers() {
                for (var set of colourSchemes) {
					d3.select('#colourSet').property('value', set);
					createPattern();
					downloadImagePNG(set);
				}
			}

			function setRandomColours(colourSet) {
				if (colourSet == 'procgen') {
					colours = getRandomColours(procgen);
				} else {
                    colours = getRandomColours(colourSchemes[colourSet]);
				}
			}

            function getRandomColours(candidates) {
                var first = '', second = '';
                do {
                    first = candidates[~~(Math.random() * candidates.length)];
                    second = candidates[~~(Math.random() * candidates.length)];
                } while (first == second);
                return [first, second];
            }

            function makeRandomColourScheme() {
            	procgen = [];
	            var hue = ~~(360 * Math.random());
	            var sat = ~~(30 + (60 * Math.random()));
	            var bri = ~~(35 + (30 * Math.random()));
	            if (Math.random() > 0.5) {
	            	// light and dark
					if (Math.random() > 0.5) {
            			procgen.push('hsl(' + hue + ', ' + sat + '%, 5%)');
            		}
		            procgen.push('hsl(' + hue + ', ' + sat + '%, 25%)');
		            if (Math.random() > 0.5) {
		            	procgen.push('hsl(' + hue + ', ' + sat + '%, 50%)');
		            }
            		procgen.push('hsl(' + hue + ', ' + sat + '%, 75%)');
            		if (Math.random() > 0.5) {
            			procgen.push('hsl(' + hue + ', ' + sat + '%, 95%)');
            		}
	            } else {
	            	// contrast
	            	switch (~~(Math.random() * 3)) {
	            		case 0: // random
		            		procgen.push('hsl(' + hue + ', ' + sat + '%, ' + bri + '%)');
		            		procgen.push('hsl(' + ((hue + 60 + ~~(Math.random() * 240)) % 360) + ', ' + sat + '%, ' + bri + '%)');
	            			break;
	            		case 1: // triple offset
		            		procgen.push('hsl(' + hue + ', ' + sat + '%, ' + bri + '%)');
			            	procgen.push('hsl(' + ((hue + 120) % 360) + ', ' + sat + '%, ' + bri + '%)');
	            			procgen.push('hsl(' + ((hue + 240) % 360) + ', ' + sat + '%, ' + bri + '%)');
	            			break;
	            		case 2: // double offset
	            			procgen.push('hsl(' + hue + ', ' + sat + '%, ' + bri + '%)');
			            	procgen.push('hsl(' + ((hue + 180) % 360) + ', ' + sat + '%, ' + bri + '%)');
	            			break;
	            	}
            		if (Math.random() > 0.5) {
            			procgen.push('white');
            			procgen.push('black');
            		} else {
            			procgen.push(Math.random() > 0.5 ? 'white' : 'black');
            		}
	            }
            }

			function createPattern() {

				makeRandomColourScheme();

				d3.selectAll('svg').remove();

				var rows = +d3.select('#rows').property('value');
				var columns = +d3.select('#columns').property('value');
				var rowsOriginal = rows;
                var columnsOriginal = columns;
				var unitSize = +d3.select('#unitSize').property('value');
				var gapSize = +d3.select('#gapSize').property('value');
				var patternSet = d3.select('#patternSet').property('value');
				var colourSet = d3.select('#colourSet').property('value');
				var maxScale = +d3.select('#maxScale').property('value');
				var maxRepetition = +d3.select('#maxRepetition').property('value');

				var isMirrored = false;
				var mirrorDirection = 'none';

				if (d3.select('#mirror').property('value') != 'none') {
					isMirrored = true;
                    mirrorDirection = d3.select('#mirror').property('value');
                }
				if (mirrorDirection == 'random') {
					switch (~~(Math.random() * 3)) {
						case 0: mirrorDirection = 'horizontal'; break;
                        case 1: mirrorDirection = 'vertical'; break;
                        case 2: mirrorDirection = 'both'; break;
					}
				}

				if (colourSet == 'random' || colourSet.length == 0) {
					var keys = Object.keys(colourSchemes);
                    colourSet = keys[~~(Math.random() * keys.length)];
                }

				var outside = d3.select('#output').append('svg');
				outside.attr('xmlns', 'http://www.w3.org/2000/svg');
				outside.attr('id', 'render');
                outside.attr('width', ((columns * (unitSize + gapSize)) - gapSize) + 'px');
				outside.attr('height', ((rows * (unitSize + gapSize)) - gapSize) + 'px');
				outside.append('defs');

				outside
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
                    .attr('width', ((columns * (unitSize + gapSize)) - gapSize))
                    .attr('height', ((rows * (unitSize + gapSize)) - gapSize));

				if (isMirrored) {
                    if (mirrorDirection == 'both' || mirrorDirection == 'horizontal') {
						columns = Math.ceil(columns / 2);
					}
                    if (mirrorDirection == 'both' || mirrorDirection == 'vertical') {
                        rows = Math.ceil(rows / 2);
                    }
				}

				var grid = [];
				for (var a = 0; a < rows; a++) {
					grid[a] = [];
					for (var b = 0; b < columns; b++) {
						grid[a].push(1);
					}
				}
				var sizes = [256, 128, 64, 32, 16, 8, 4, 2];
				for (var size of sizes) {
                    if (size <= maxScale || size <= maxRepetition) {
						if (rows >= size && columns >= size) {
							for (var a = 0; a < 50; a++) {
								var checkR = ~~(Math.random() * (1 + rows - size));
								var checkC = ~~(Math.random() * (1 + columns - size));
								var success = true;
								for (var r = checkR; r < checkR + size; r++) {
									for (var c = checkC; c < checkC + size; c++) {
										if (grid[r][c] != 1) {
											success = false;
										}
										if (mirrorDirection != 'none') {
											switch (mirrorDirection) {
												case 'both':
													if ((columnsOriginal % 2 == 1 && c == columns - 1) ||
														(rowsOriginal % 2 == 1 && r == rows - 1)) {
                                                        success = false;
                                                    }
													break;
												case 'horizontal':
													if (columnsOriginal % 2 == 1 && c == columns - 1) {
														success = false;
													}
													break;
                                                case 'vertical':
                                                    if (rowsOriginal % 2 == 1 && r == rows - 1) {
                                                        success = false;
                                                    }
                                                    break;
											}
										}
									}
								}
								if (success) {
									for (var r = checkR; r < checkR + size; r++) {
										for (var c = checkC; c < checkC + size; c++) {
											grid[r][c] = '0';
										}
									}
									grid[checkR][checkC] = size;
								}
							}
						}
					}
				}

				var inside = outside.append('g');

				for (var a = 0; a < columns; a++) {
					for (var b = 0; b < rows; b++) {
						if (grid[b][a] > 0) {

							var isRepeated = false;

							var extraLength = 0;
							if (grid[b][a] > 1) {
								switch (grid[b][a]) {
									case 2: extraLength = gapSize * 0.5; break;
									case 4: extraLength = gapSize * 0.75; break;
									case 8: extraLength = gapSize * 0.875; break;
									case 16: extraLength = gapSize * 0.94; break;
									case 32: extraLength = gapSize * 0.97; break;
									case 64: extraLength = gapSize * 0.985; break;
								}
								var allowedRepetition = maxRepetition >= grid[b][a];
								var allowedScaling = maxScale >= grid[b][a];
								if (allowedRepetition) {
									if (allowedScaling) {
										isRepeated = Math.random() > 0.5;
									} else {
										isRepeated = true;
									}
								}
							}
							if (isRepeated) {
								createRandomPattern(
									colourSet,
									grid[b][a],
									patternSet,
									outside,
									inside,
									a * (unitSize + gapSize),
									b * (unitSize + gapSize),
									unitSize,
									0,
                                    gapSize,
									true,
									false,
									'none');
							} else {
								var mirrorType = 'none';
                                if (mirrorDirection != 'none') {
									switch (mirrorDirection) {
										case 'both':
                                            if (columnsOriginal % 2 == 1 && a == columns - 1) {
                                                mirrorType = 'horizontal';
											}
                                            if (rowsOriginal % 2 == 1 && b == rows - 1) {
                                                mirrorType = 'vertical';
                                            }
											if ((columnsOriginal % 2 == 1 && a == columns - 1) &&
												(rowsOriginal % 2 == 1 && b == rows - 1)) {
													mirrorType = 'both';
											}
											break;
                                        case 'horizontal':
                                            if (columnsOriginal % 2 == 1 && a == columns - 1) {
                                                mirrorType = mirrorDirection;
                                            }
                                            break;
                                        case 'vertical':
                                            if (rowsOriginal % 2 == 1 && b == rows - 1) {
                                                mirrorType = mirrorDirection;
                                            }
                                            break;
                                    }
								}

                                createRandomPattern(
                                    colourSet,
                                    grid[b][a],
                                    patternSet,
									outside,
									inside,
                                    a * (unitSize + gapSize),
                                    b * (unitSize + gapSize),
									unitSize,
									extraLength,
									gapSize,
									false,
									false,
                                    mirrorType);
							}
						}
					}
				}

				if (isMirrored) {
					switch (mirrorDirection) {
						case 'horizontal':
							var duplicate = inside.clone(true);
							duplicate.attr('transform', 'translate(' + +outside.attr('width').replace('px', '') + ',0) scale(-1,1)');
							break;
						case 'vertical':
                            var duplicate = inside.clone(true);
							duplicate.attr('transform', 'translate(0,' + +outside.attr('height').replace('px', '') + ') scale(1,-1)');
							break;
						case 'both':
							var duplicateTopRight = inside.clone(true);
							duplicateTopRight.attr('transform', 'translate(' + +outside.attr('width').replace('px', '') + ',0) scale(-1,1)');
                            var duplicateBottomLeft = inside.clone(true);
							duplicateBottomLeft.attr('transform', 'translate(0,' + +outside.attr('height').replace('px', '') + ') scale(1,-1)');
                            var duplicateBottomRight = inside.clone(true);
                            duplicateBottomRight.attr('transform', 'translate(' + +outside.attr('width').replace('px', '') + ',' + (+outside.attr('height').replace('px', '') - 0) + ') scale(-1,-1)');
							break;
					}
				}

				inside.raise();

                outside.attr('fill', colours[0]);

				d3.select('#downloadSVG').style('display', null);
                d3.select('#downloadPNG').style('display', null);
				d3.select('#about').style('display', null);
				d3.select('#footer').style('display', null);

				d3.selectAll('rect').attr('shape-rendering', 'crispEdges');
				d3.selectAll('polygon').attr('shape-rendering', 'crispEdges');
			}

			function chooseRandomPattern(patternSet, mirrorType) {

                var available = [
                    createPatternCircleNormal,
                    createPatternCircleLarge,
                    createPatternCircleLargeRing,
                    //createPatternCircleQuad,
                    createPatternCircleOpposites,
                    createPatternSquareNormal,
                    createPatternSquareGrid,
                    createPatternSquareOpposites,
                    createPatternRectangle,
                    createPatternCornerTriangle,
                    createPatternTriangleSideNormal,
                    createPatternTriangleSideDouble,
                    createPatternTriangleSideDoubleRotate,
                    createPatternTriangleQuad,
                    createPatternArrow,
                    createPatternDiamondNormal,
                    createPatternDiamondLarge,
                    createPatternDiamondRing,
                    createPatternArcSolid,
                    createPatternArcRing,
                    createPatternArcRingTwin,
                    //createPatternArcQuartersAll,
                    createPatternArcQuartersOpposites,
                    createPatternLinesStraight,
                    createPatternLinesDiagonal,
                    createPatternLinesDiagonalPair,
                    createPatternLinesArc,
                ];

                switch (patternSet) {
                    case 'curves':
                        available = [
                            createPatternCircleNormal,
                            createPatternCircleLarge,
                            createPatternCircleLargeRing,
                            createPatternCircleOpposites,
                            //createPatternCircleQuad,
                            createPatternArcSolid,
                            createPatternArcRing,
                            createPatternArcRingTwin,
                            //createPatternArcQuartersAll,
                            createPatternArcQuartersOpposites,
                            createPatternLinesArc,
                        ];
                        break;
                    case 'diagonals':
                        available = [
                            createPatternCornerTriangle,
                            createPatternTriangleSideNormal,
                            createPatternTriangleSideDouble,
                            createPatternTriangleSideDoubleRotate,
                            createPatternTriangleQuad,
                            createPatternArrow,
                            createPatternDiamondNormal,
                            createPatternDiamondLarge,
                            createPatternDiamondRing,
                            //createPatternLinesDiagonal,
                            createPatternLinesDiagonalPair,
                        ];
                        break;
                    case 'lines':
                        available = [
                            createPatternLinesStraight,
                            createPatternLinesDiagonal,
                            createPatternLinesArc,
                        ];
                        break;
                    case 'straights':
                        available = [
                            createPatternSquareNormal,
                            createPatternSquareGrid,
                            createPatternSquareOpposites,
                            createPatternRectangle,
                            createPatternLinesStraight,
                        ];
                        break;
                    case 'triangles':
                        available = [
                            createPatternCornerTriangle,
                            createPatternTriangleSideNormal,
                            createPatternTriangleSideDouble,
                            createPatternTriangleSideDoubleRotate,
                            createPatternTriangleQuad,
                        ];
                        break;
                }

                switch (mirrorType) {
                    case 'both':
                        available = available
                            .filter(x =>
                                x == createPatternCircleNormal ||
                                x == createPatternCircleLarge ||
                                x == createPatternCircleLargeRing ||
                                x == createPatternCircleOpposites ||
                                x == createPatternSquareNormal |
                                x == createPatternTriangleSideDouble ||
                                x == createPatternDiamondNormal ||
                                x == createPatternDiamondLarge ||
                                x == createPatternDiamondRing);
                        break;
                    case 'horizontal':
                    case 'vertical':
                        available = available
                            .filter(x =>
                                x == createPatternCircleNormal ||
                                x == createPatternCircleLarge ||
                                x == createPatternCircleLargeRing ||
                                x == createPatternCircleOpposites ||
                                x == createPatternSquareNormal ||
                                x == createPatternRectangle ||
                                x == createPatternTriangleSideNormal ||
                                x == createPatternTriangleSideDouble ||
                                x == createPatternArrow ||
                                x == createPatternDiamondNormal ||
                                x == createPatternDiamondLarge ||
                                x == createPatternDiamondRing ||
                                x == createPatternLinesStraight);
                        break;
				}

				if (available.length > 0) {
					return available[~~(Math.random() * available.length)];
				} else {
					return null;
				}

			}

			function createRandomPattern(colourSet, scale, patternSet, svg, container, x, y, s, extra, gap = 0, repetition, overwrite, mirrorType) {

				setRandomColours(colourSet);

				var chosen = chooseRandomPattern(patternSet, mirrorType);
                if (chosen != null) {

					var g = container;

					if (!overwrite) {

                        var id = '_' + x + '_' + y;
                        var defs = svg.select('defs');

						defs
							.append('clipPath')
							.attr('id', 'clip' + id)
							.append('rect')
							.attr('x', 0)
							.attr('y', 0)
							.attr('width', s + extra)
							.attr('height', s + extra);

                        var pattern = defs
                            .append('pattern')
                            .attr('id', 'pat' + id)
							.attr('patternUnits', 'userSpaceOnUse');
                        g = pattern
                            .append('g')
                            .attr('id', 'box' + id)
                            .attr('clip-path', 'url(#clip' + id + ')');

						if (repetition) {
							pattern
								.attr('width', s + gap)
								.attr('height', s + gap);
						} else {
							pattern
								.attr('x', x)
								.attr('y', y)
								.attr('width', (s + gap) * scale)
								.attr('height', (s + gap) * scale);
							g.attr('transform', 'scale(' + scale + ')');
						}

                        container
                            .append('rect')
                            .attr('x', x)
                            .attr('y', y)
                            .attr('width', (s + gap) * scale)
                            .attr('height', (s + gap) * scale)
                            .attr('fill', 'url(#pat' + id + ')')
							.on('click', function () {
                                var id = '_' + x + '_' + y;
                                d3.selectAll('#box' + id + ' *').remove();
                                var container = d3.select('#box' + id);
                                createRandomPattern(colourSet, null, patternSet, null, container, null, null, s, extra, null, null, true, mirrorType);
                                d3.event.stopPropagation();
							});

					}

                    chosen(g, s + extra, mirrorType);
				}
			}

			function createPatternCircleNormal(g, s) {
				createPatternCircle(g, s, large = false, ring = false);
			}

			function createPatternCircleLarge(g, s) {
				createPatternCircle(g, s, large = true, ring = false);
			}

			function createPatternCircleLargeRing(g, s) {
				createPatternCircle(g, s, large = true, ring = true);
			}

			function createPatternCircle(g, s, large = false, ring = false) {
				var fill = colours[0];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', colours[0]);
				fill = colours[1];
				g
					.append('circle')
					.attr('cx', s / 2)
					.attr('cy', s / 2)
					.attr('r', s * (ring || large ? 0.5 : 0.25))
					.attr('fill', fill)
				if (ring) {
					fill = fill == colours[1] ? colours[0] : colours[1];
					g
						.append('circle')
						.attr('cx', s / 2)
						.attr('cy', s / 2)
						.attr('r', s * 0.25)
						.attr('fill', fill)
				}
			}

			function createPatternCircleQuad(g, s) {
				var fill = colours[0];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', colours[0]);
				fill = colours[1];
				for (var a of [0, s / 2]) {
					for (var b of [0, s / 2]) {
						g
							.append('circle')
							.attr('cx', a + s / 4)
							.attr('cy', b + s / 4)
							.attr('r', s * 0.15)
							.attr('fill', fill)
					}
				}
			}

			function createPatternCircleOpposites(g, s, mirrorType = 'none') {

				var fill = colours[0];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];

				var x1 = 0, y1 = s / 2;
				var x2 = s, y2 = s / 2;

				if (Math.random() > 0.5) {
					x1 = s / 2, y1 = 0;
					x2 = s / 2, y2 = s;
				}

				g
					.append('circle')
					.attr('cx', x1)
					.attr('cy', y1)
					.attr('r', s / 2)
					.attr('fill', fill)

				if (mirrorType == 'none' && Math.random() > 0.5) {
					g
						.append('rect')
						.attr('x', x2 - s / 2)
						.attr('y', y2 - s / 2)
						.attr('width', s)
						.attr('height', s)
						.attr('fill', fill);
					fill = fill == colours[1] ? colours[0] : colours[1];
				}

				g
					.append('circle')
					.attr('cx', x2)
					.attr('cy', y2)
					.attr('r', s / 2)
					.attr('fill', fill)
			}

			function createPatternSquareNormal(g, s) {
				var fill = colours[0];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];
				g
					.append('rect')
					.attr('shape-rendering', 'crispEdges')
					.attr('x', s * 0.25)
					.attr('y', s * 0.25)
					.attr('width', s * 0.5)
					.attr('height', s * 0.5)
					.attr('fill', fill);
			}

			function createPatternSquareGrid(g, s) {
				var fill = colours[0];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];
				var offset = Math.random() > 0.5 ? 0 : 1;
				for (var a = 0; a < 4; a++) {
					for (var b = 0; b < 4; b++) {
						if ((a + b) % 2 == offset) {
							g
								.append('rect')
								.attr('x', s / 4 * a)
								.attr('y', s / 4 * b)
								.attr('width', s * 0.25)
								.attr('height', s * 0.25)
								.attr('fill', fill);
						}
					}
				}
			}

			function createPatternSquareOpposites(g, s) {
				var fill = colours[0];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];
				var offset = Math.random() > 0.5 ? 0 : 1;
				for (var a = 0; a < 2; a++) {
					for (var b = 0; b < 2; b++) {
						if ((a + b) % 2 == offset) {
							g
								.append('rect')
								.attr('x', s / 2 * a)
								.attr('y', s / 2 * b)
								.attr('width', s * 0.5)
								.attr('height', s * 0.5)
								.attr('fill', fill);
						}
					}
				}
			}

            function createPatternRectangle(g, s, mirrorType = 'none') {
				var fill = colours[0];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];

				var direction = Math.random() > 0.5 ? 'v' : 'h';
				switch (mirrorType) {
					case 'vertical':
						direction = 'v';
						break;
					case 'horizontal':
                        direction = 'h';
						break;
				}

				if (direction == 'v') {
					g
						.append('rect')
						.attr('x', 0)
						.attr('y', 0)
						.attr('width', s * 0.5)
						.attr('height', s * 1)
						.attr('fill', fill);
				} else {
					g
						.append('rect')
						.attr('x', 0)
						.attr('y', 0)
						.attr('width', s * 1)
						.attr('height', s * 0.5)
						.attr('fill', fill);
				}
			}

			function createPatternCornerTriangle(g, s) {

				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', colours[0]);

				var points =
					[
						'0,0 ',
						s + ',0 ',
						s + ',' + s + ' ',
						'0,' + s + ' '
					];

				var start = ~~(Math.random() * 4);

				g
					.append('polygon')
					.attr('points', points[start] + points[(start + 1) % 4] + points[(start + 2) % 4])
					.attr('fill', colours[1]);
			}

            function createPatternTriangleSideNormal(g, s, mirrorType = 'none') {
				createPatternTriangleSide(g, s, mirrorType, double = false, rotate = false);
			}

            function createPatternTriangleSideDouble(g, s) {
                createPatternTriangleSide(g, s, 'none', double = true, rotate = false);
			}

            function createPatternTriangleSideDoubleRotate(g, s) {
                createPatternTriangleSide(g, s, 'none', double = true, rotate = true);
			}

			function createPatternTriangleSide(g, s, mirrorType = 'none', double = false, rotate = false) {

				var fill = colours[0];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];

				var points =
					[
						'0,0 ',
						s + ',0 ',
						s + ',' + s + ' ',
						'0,' + s + ' '
					];

				var start = ~~(Math.random() * 4);
				switch (mirrorType) {
					case 'horizontal':
						start = Math.random() > 0.5 ? 0 : 2;
						break;
					case 'vertical':
                        start = Math.random() > 0.5 ? 1 : 3;
						break;
				}

				g
					.append('polygon')
					.attr('points', points[start] + (s / 2) + ',' + (s / 2) + ' ' + points[(start + 1) % 4])
					.attr('fill', fill);

				if (double) {
					var offsetX = 0, offsetY = 0;
					switch (start) {
						case 0: offsetY += s / 2; break;
						case 1: offsetX -= s / 2; break;
						case 2: offsetY -= s / 2; break;
						case 3: offsetX += s / 2; break;
					}

					if (rotate) {
						g
							.append('polygon')
							.attr('transform', 'translate(' + offsetX + ' ' + offsetY + ')')
							.attr('points', points[start] + (s / 2) + ',' + (s / 2) + ' ' + points[(start + 1) % 4])
							.attr('fill', fill);
					} else {
						start += 2;
						g
							.append('polygon')
							.attr('points', points[start % 4] + (s / 2) + ',' + (s / 2) + ' ' + points[(start + 1) % 4])
							.attr('fill', fill);
					}
				}
			}

			function createPatternTriangleQuad(g, s) {

				var fill = colours[0];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];

				var points =
					[
						'0,0 ',
						(s / 2) + ',0 ',
						(s / 2) + ',' + (s / 2) + ' ',
						'0,' + (s / 2) + ' '
					];

				var start = ~~(Math.random() * 4);

				for (var a of [0, s / 2]) {
					for (var b of [0, s / 2]) {
						g
							.append('polygon')
							.attr('transform', 'translate(' + a + ' ' + b + ')')
							.attr('points', points[start] + points[(start + 1) % 4] + points[(start + 2) % 4])
							.attr('fill', fill);
					}
				}
			}

            function createPatternArrow(g, s, mirrorType = 'none') {
                var fill = colours[0];
                g
                    .append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', s)
                    .attr('height', s)
                    .attr('fill', fill);
                fill = fill == colours[1] ? colours[0] : colours[1];

                var points =
					[
						s/2 + ',0 ',
						s + ',' + s/2 + ' ',
						s + ',' + s + ' ',
						s/2 + ',' + s/2 + ' ',
						'0,' + s + ' ',
						'0,' + s/2
					];

				var rotate = ~~(Math.random() * 4);
                switch (mirrorType) {
                    case 'horizontal':
                        rotate = Math.random() > 0.5 ? 0 : 2;
                        break;
                    case 'vertical':
                        rotate = Math.random() > 0.5 ? 1 : 3;
                        break;
                }

				g
					.append('g')
					.attr('transform-origin', s/2 + ' ' + s/2)
                    .attr('transform', 'rotate(' + (90*rotate) + ')')
                    .append('polygon')
					.attr('points', points.join(''))
                    .attr('fill', fill);
            }

			function createPatternDiamondNormal(g, s) {
				createPatternDiamond(g, s, large = false, small = true);
			}

			function createPatternDiamondLarge(g, s) {
				createPatternDiamond(g, s, large = true, small = false);
			}

			function createPatternDiamondRing(g, s) {
				createPatternDiamond(g, s, large = true, small = true);
			}

			function createPatternDiamond(g, s, large = false, small = false) {
				var fill = colours[0];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];

				var points =
					[
						(s / 2) + ',0 ',
						s + ',' + (s / 2) + ' ',
						(s / 2) + ',' + s + ' ',
						'0,' + (s / 2) + ' '
					];

				if (large) {
					g
						.append('polygon')
						.attr('points', points.join(' '))
						.attr('fill', fill);
					fill = fill == colours[1] ? colours[0] : colours[1];
				}

				if (small) {
					var points =
						[
							(s / 2) + ',' + (s / 4) + ' ',
							(s * 0.75) + ',' + (s / 2) + ' ',
							(s / 2) + ',' + (s * 0.75) + ' ',
							(s / 4) + ',' + (s / 2) + ' '
						];
					g
						.append('polygon')
						.attr('points', points.join(' '))
						.attr('fill', fill);
				}
			}

			function createPatternArcSolid(g, s) {
				createPatternArc(g, s, ring = false, twin = false);
			}

			function createPatternArcRing(g, s) {
				createPatternArc(g, s, ring = true, twin = false);
			}

			function createPatternArcRingTwin(g, s) {
				createPatternArc(g, s, ring = true, twin = true);
			}

			function createPatternArc(g, s, ring = false, twin = false) {

				var x = 0, y = 0;

				var fill = Math.random() > 0.5 ? colours[0] : colours[1];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];

				if (twin) {
					g
						.append('circle')
						.attr('cx', s / 2)
						.attr('cy', s / 2)
						.attr('r', s / 2)
						.attr('fill', fill);
					switch (~~(Math.random() * 4)) {
						case 0: x = s / 2; break;
						case 1: x = s; y = s / 2; break;
						case 2: x = s / 2; y = s; break;
						case 3: x = s / 2; y = s; break;
					}
					g
						.append('rect')
						.attr('x', x - s / 2)
						.attr('y', y - s / 2)
						.attr('width', s)
						.attr('height', s)
						.attr('fill', fill);
				} else {
					switch (~~(Math.random() * 4)) {
						case 0: break;
						case 1: x = s; break;
						case 2: y = s; break;
						case 3: x = s; y = s; break;
					}
					g
						.append('circle')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', s)
						.attr('fill', fill);
				}

				if (ring) {
					fill = fill == colours[1] ? colours[0] : colours[1];
					g
						.append('circle')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', s / 2)
						.attr('fill', fill);
				}
			}

			function createPatternArcQuartersAll(g, s) {
				createPatternArcQuarters(g, s, opposites = false);
			}

			function createPatternArcQuartersOpposites(g, s) {
				createPatternArcQuarters(g, s, opposites = true);
			}

			function createPatternArcQuarters(g, s, opposites = false) {

				var fill = Math.random() > 0.5 ? colours[0] : colours[1];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];

				var include = [1, 1, 1, 1];
				if (opposites) {
					include = Math.random() > 0.5 ? [1, 0, 0, 1] : [0, 1, 1, 0];
				}

				var count = 0;
				for (var a = 0; a <= 1; a++) {
					for (var b = 0; b <= 1; b++) {
						if (include[count++]) {
							g
								.append('circle')
								.attr('cx', a * s)
								.attr('cy', b * s)
								.attr('r', s / 2)
								.attr('fill', fill);
						}
					}
				}
			}

            function createPatternLinesStraight(g, s, mirrorType = 'none') {
				var fill = Math.random() > 0.5 ? colours[0] : colours[1];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];

				var thickness = s / lines;
				var vertical = Math.random() > 0.5;
                switch (mirrorType) {
                    case 'horizontal':
						vertical = false;
                        break;
                    case 'vertical':
						vertical = true;
                        break;
                }

				for (var a = 1; a < lines; a += 2) {
					if (vertical) {
                        g
                            .append('rect')
                            .attr('x', s / lines * a)
                            .attr('y', 0)
                            .attr('width', thickness)
                            .attr('height', s)
                            .attr('fill', fill);
					} else {
                        g
                            .append('rect')
                            .attr('x', 0)
                            .attr('y', s / lines * a)
                            .attr('width', s)
                            .attr('height', thickness)
                            .attr('fill', fill);
					}
				}
			}

			function createPatternLinesDiagonal(g, s) {

				var fill = Math.random() > 0.5 ? colours[0] : colours[1];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];

				var ratio = 0.71;
				var thickness = (s / lines) * ratio;
				var opposite = Math.random() > 0.5;
				var extend = s;

				for (var a = 1; a < (lines * 2); a += 2) {
					var line = g
						.append('line')
						.attr('y1', -extend)
						.attr('y2', extend + s)
						.attr('stroke-width', thickness)
						.attr('stroke', fill);
					if (opposite) {
						line
							.attr('x1', extend + (thickness * ratio) + ((s * 2) / (lines * 2) * a))
							.attr('x2', -extend + (thickness * ratio) + ((s * 2) / (lines * 2) * a) + -s);
					} else {
						line
							.attr('x1', -extend + (thickness * ratio) + ((s * 2) / (lines * 2) * a) + -s)
							.attr('x2', extend + (thickness * ratio) + ((s * 2) / (lines * 2) * a));
					}
				}
			}

            function createPatternLinesDiagonalPair(g, s) {
                var fill = Math.random() > 0.5 ? colours[0] : colours[1];
                g
                    .append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', s)
                    .attr('height', s)
                    .attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];

				var container =
					g
						.append('g')
						.attr('transform-origin', s / 2 + ' ' + s / 2)
						.attr('transform', 'rotate(' + (90 * ~~(Math.random() * 4)) + ')');

                var points =
					[
						0   + ',' + 0   + ' ',
						s/2 + ',' + 0   + ' ',
						s   + ',' + s/2 + ' ',
						s   + ',' + s   + ' '
					];

                container
                    .append('polygon')
                    .attr('points', points.join(''))
					.attr('fill', fill);

                points =
                    [
                        0   + ',' + s/2 + ' ',
                        s/2 + ',' + s   + ' ',
                        0   + ',' + s   + ' ',
                    ];

                container
                    .append('polygon')
                    .attr('points', points.join(''))
                    .attr('fill', fill);
            }

			function createPatternLinesArc(g, s) {

				var x = 0, y = 0;

				var fill = Math.random() > 0.5 ? colours[0] : colours[1];
				g
					.append('rect')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', s)
					.attr('height', s)
					.attr('fill', fill);
				fill = fill == colours[1] ? colours[0] : colours[1];

				switch (~~(Math.random() * 4)) {
					case 0: break;
					case 1: x = s; break;
					case 2: y = s; break;
					case 3: x = s; y = s; break;
				}

				for (var a = lines; a > 0; a--) {
					g
						.append('circle')
						.attr('cx', x)
						.attr('cy', y)
						.attr('r', s / lines * a)
						.attr('fill', fill);
					fill = fill == colours[1] ? colours[0] : colours[1];
				}
			}

		</script>
	</body>
</html>